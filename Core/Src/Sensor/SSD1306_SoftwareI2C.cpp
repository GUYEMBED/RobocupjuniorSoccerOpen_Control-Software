#include "SSD1306_SoftwareI2C.h"
#include "stm32f4xx_hal.h"  // Adjust include if needed

// 5x7 font data for ASCII 32-127 (partial example, add more chars as needed)
const uint8_t SSD1306_SoftwareI2C::Font5x7[][5] = { { 0x00, 0x00, 0x00, 0x00,
		0x00 }, // 32 ' '
		{ 0x00, 0x00, 0x5F, 0x00, 0x00 }, // 33 '!'
		{ 0x00, 0x07, 0x00, 0x07, 0x00 }, // 34 '"'
		{ 0x14, 0x7F, 0x14, 0x7F, 0x14 }, // 35 '#'
		{ 0x24, 0x2A, 0x7F, 0x2A, 0x12 }, // 36 '$'
		{ 0x23, 0x13, 0x08, 0x64, 0x62 }, // 37 '%'
		{ 0x36, 0x49, 0x55, 0x22, 0x50 }, // 38 '&'
		{ 0x00, 0x05, 0x03, 0x00, 0x00 }, // 39 '''
		{ 0x00, 0x1C, 0x22, 0x41, 0x00 }, // 40 '('
		{ 0x00, 0x41, 0x22, 0x1C, 0x00 }, // 41 ')'
		{ 0x14, 0x08, 0x3E, 0x08, 0x14 }, // 42 '*'
		{ 0x08, 0x08, 0x3E, 0x08, 0x08 }, // 43 '+'
		{ 0x00, 0x50, 0x30, 0x00, 0x00 }, // 44 ','
		{ 0x08, 0x08, 0x08, 0x08, 0x08 }, // 45 '-'
		{ 0x00, 0x60, 0x60, 0x00, 0x00 }, // 46 '.'
		{ 0x20, 0x10, 0x08, 0x04, 0x02 }, // 47 '/'
		{ 0x3E, 0x51, 0x49, 0x45, 0x3E }, // 48 '0'
		{ 0x00, 0x42, 0x7F, 0x40, 0x00 }, // 49 '1'
		{ 0x42, 0x61, 0x51, 0x49, 0x46 }, // 50 '2'
		{ 0x21, 0x41, 0x45, 0x4B, 0x31 }, // 51 '3'
		{ 0x18, 0x14, 0x12, 0x7F, 0x10 }, // 52 '4'
		{ 0x27, 0x45, 0x45, 0x45, 0x39 }, // 53 '5'
		{ 0x3C, 0x4A, 0x49, 0x49, 0x30 }, // 54 '6'
		{ 0x01, 0x71, 0x09, 0x05, 0x03 }, // 55 '7'
		{ 0x36, 0x49, 0x49, 0x49, 0x36 }, // 56 '8'
		{ 0x06, 0x49, 0x49, 0x29, 0x1E }, // 57 '9'
		{ 0x00, 0x36, 0x36, 0x00, 0x00 }, // 58 ':'
		{ 0x00, 0x56, 0x36, 0x00, 0x00 }, // 59 ';'
		{ 0x08, 0x14, 0x22, 0x41, 0x00 }, // 60 '<'
		{ 0x14, 0x14, 0x14, 0x14, 0x14 }, // 61 '='
		{ 0x00, 0x41, 0x22, 0x14, 0x08 }, // 62 '>'
		{ 0x02, 0x01, 0x51, 0x09, 0x06 }, // 63 '?'
		{ 0x32, 0x49, 0x79, 0x41, 0x3E }, // 64 '@'
		{ 0x7E, 0x11, 0x11, 0x11, 0x7E }, // 65 'A'
		{ 0x7F, 0x49, 0x49, 0x49, 0x36 }, // 66 'B'
		{ 0x3E, 0x41, 0x41, 0x41, 0x22 }, // 67 'C'
		{ 0x7F, 0x41, 0x41, 0x22, 0x1C }, // 68 'D'
		{ 0x7F, 0x49, 0x49, 0x49, 0x41 }, // 69 'E'
		{ 0x7F, 0x09, 0x09, 0x09, 0x01 }, // 70 'F'
		{ 0x3E, 0x41, 0x49, 0x49, 0x7A }, // 71 'G'
		{ 0x7F, 0x08, 0x08, 0x08, 0x7F }, // 72 'H'
		{ 0x00, 0x41, 0x7F, 0x41, 0x00 }, // 73 'I'
		{ 0x20, 0x40, 0x41, 0x3F, 0x01 }, // 74 'J'
		{ 0x7F, 0x08, 0x14, 0x22, 0x41 }, // 75 'K'
		{ 0x7F, 0x40, 0x40, 0x40, 0x40 }, // 76 'L'
		{ 0x7F, 0x02, 0x0C, 0x02, 0x7F }, // 77 'M'
		{ 0x7F, 0x04, 0x08, 0x10, 0x7F }, // 78 'N'
		{ 0x3E, 0x41, 0x41, 0x41, 0x3E }, // 79 'O'
		{ 0x7F, 0x09, 0x09, 0x09, 0x06 }, // 80 'P'
		{ 0x3E, 0x41, 0x51, 0x21, 0x5E }, // 81 'Q'
		{ 0x7F, 0x09, 0x19, 0x29, 0x46 }, // 82 'R'
		{ 0x46, 0x49, 0x49, 0x49, 0x31 }, // 83 'S'
		{ 0x01, 0x01, 0x7F, 0x01, 0x01 }, // 84 'T'
		{ 0x3F, 0x40, 0x40, 0x40, 0x3F }, // 85 'U'
		{ 0x1F, 0x20, 0x40, 0x20, 0x1F }, // 86 'V'
		{ 0x3F, 0x40, 0x38, 0x40, 0x3F }, // 87 'W'
		{ 0x63, 0x14, 0x08, 0x14, 0x63 }, // 88 'X'
		{ 0x07, 0x08, 0x70, 0x08, 0x07 }, // 89 'Y'
		{ 0x61, 0x51, 0x49, 0x45, 0x43 }, // 90 'Z'
		{ 0x00, 0x7F, 0x41, 0x41, 0x00 }, // 91 '['
		{ 0x02, 0x04, 0x08, 0x10, 0x20 }, // 92 '\'
		{ 0x00, 0x41, 0x41, 0x7F, 0x00 }, // 93 ']'
		{ 0x04, 0x02, 0x01, 0x02, 0x04 }, // 94 '^'
		{ 0x40, 0x40, 0x40, 0x40, 0x40 }, // 95 '_'
		{ 0x00, 0x01, 0x02, 0x04, 0x00 }, // 96 '`'
		{ 0x20, 0x54, 0x54, 0x54, 0x78 }, // 97 'a'
		{ 0x7F, 0x48, 0x44, 0x44, 0x38 }, // 98 'b'
		{ 0x38, 0x44, 0x44, 0x44, 0x20 }, // 99 'c'
		{ 0x38, 0x44, 0x44, 0x48, 0x7F }, // 100 'd'
		{ 0x38, 0x54, 0x54, 0x54, 0x18 }, // 101 'e'
		{ 0x08, 0x7E, 0x09, 0x01, 0x02 }, // 102 'f'
		{ 0x0C, 0x52, 0x52, 0x52, 0x3E }, // 103 'g'
		{ 0x7F, 0x08, 0x04, 0x04, 0x78 }, // 104 'h'
		{ 0x00, 0x44, 0x7D, 0x40, 0x00 }, // 105 'i'
		{ 0x20, 0x40, 0x44, 0x3D, 0x00 }, // 106 'j'
		{ 0x7F, 0x10, 0x28, 0x44, 0x00 }, // 107 'k'
		{ 0x00, 0x41, 0x7F, 0x40, 0x00 }, // 108 'l'
		{ 0x7C, 0x04, 0x18, 0x04, 0x78 }, // 109 'm'
		{ 0x7C, 0x08, 0x04, 0x04, 0x78 }, // 110 'n'
		{ 0x38, 0x44, 0x44, 0x44, 0x38 }, // 111 'o'
		{ 0x7C, 0x14, 0x14, 0x14, 0x08 }, // 112 'p'
		{ 0x08, 0x14, 0x14, 0x18, 0x7C }, // 113 'q'
		{ 0x7C, 0x08, 0x04, 0x04, 0x08 }, // 114 'r'
		{ 0x48, 0x54, 0x54, 0x54, 0x20 }, // 115 's'
		{ 0x04, 0x3F, 0x44, 0x40, 0x20 }, // 116 't'
		{ 0x3C, 0x40, 0x40, 0x20, 0x7C }, // 117 'u'
		{ 0x1C, 0x20, 0x40, 0x20, 0x1C }, // 118 'v'
		{ 0x3C, 0x40, 0x30, 0x40, 0x3C }, // 119 'w'
		{ 0x44, 0x28, 0x10, 0x28, 0x44 }, // 120 'x'
		{ 0x0C, 0x50, 0x50, 0x50, 0x3C }, // 121 'y'
		{ 0x44, 0x64, 0x54, 0x4C, 0x44 }, // 122 'z'
		{ 0x00, 0x08, 0x36, 0x41, 0x00 }, // 123 '{'
		{ 0x00, 0x00, 0x7F, 0x00, 0x00 }, // 124 '|'
		{ 0x00, 0x41, 0x36, 0x08, 0x00 }, // 125 '}'
		{ 0x10, 0x08, 0x08, 0x10, 0x08 }, // 126 '~'
		};

SSD1306_SoftwareI2C::SSD1306_SoftwareI2C(GPIO_TypeDef *sclPort, uint16_t sclPin,
		GPIO_TypeDef *sdaPort, uint16_t sdaPin) :
		_sclPort(sclPort), _sclPin(sclPin), _sdaPort(sdaPort), _sdaPin(sdaPin) {
}

// Delay function for bit-banging (approx 5us)
void SSD1306_SoftwareI2C::i2cDelay() {
	for (volatile int i = 0; i < 30; i++)
		__NOP();
}

void SSD1306_SoftwareI2C::i2cStart() {
	HAL_GPIO_WritePin(_sdaPort, _sdaPin, GPIO_PIN_SET);
	HAL_GPIO_WritePin(_sclPort, _sclPin, GPIO_PIN_SET);
	i2cDelay();
	HAL_GPIO_WritePin(_sdaPort, _sdaPin, GPIO_PIN_RESET);
	i2cDelay();
	HAL_GPIO_WritePin(_sclPort, _sclPin, GPIO_PIN_RESET);
	i2cDelay();
}

void SSD1306_SoftwareI2C::i2cStop() {
	HAL_GPIO_WritePin(_sdaPort, _sdaPin, GPIO_PIN_RESET);
	HAL_GPIO_WritePin(_sclPort, _sclPin, GPIO_PIN_SET);
	i2cDelay();
	HAL_GPIO_WritePin(_sdaPort, _sdaPin, GPIO_PIN_SET);
	i2cDelay();
}

bool SSD1306_SoftwareI2C::i2cWriteByte(uint8_t byte) {
	for (int i = 0; i < 8; i++) {
		HAL_GPIO_WritePin(_sdaPort, _sdaPin,
				(byte & 0x80) ? GPIO_PIN_SET : GPIO_PIN_RESET);
		i2cDelay();
		HAL_GPIO_WritePin(_sclPort, _sclPin, GPIO_PIN_SET);
		i2cDelay();
		HAL_GPIO_WritePin(_sclPort, _sclPin, GPIO_PIN_RESET);
		i2cDelay();
		byte <<= 1;
	}

	// Read ACK (ignore for simplicity, but wait for slave to pull SDA low)
	HAL_GPIO_WritePin(_sdaPort, _sdaPin, GPIO_PIN_SET); // Release SDA for ACK
	i2cDelay();
	HAL_GPIO_WritePin(_sclPort, _sclPin, GPIO_PIN_SET);
	i2cDelay();

	// Optional: read pin to check ACK, but here we just wait a bit
	HAL_GPIO_WritePin(_sclPort, _sclPin, GPIO_PIN_RESET);
	i2cDelay();

	return true; // assume ACK
}

void SSD1306_SoftwareI2C::sendCommand(uint8_t cmd) {
	i2cStart();
	i2cWriteByte(0x78);      // OLED I2C address (0x3C << 1)
	i2cWriteByte(0x00);      // Co = 0, D/C# = 0 (command)
	i2cWriteByte(cmd);
	i2cStop();
}

void SSD1306_SoftwareI2C::sendData(uint8_t *data, uint16_t size) {
	i2cStart();
	i2cWriteByte(0x78);      // OLED I2C address (0x3C << 1)
	i2cWriteByte(0x40);      // Co = 0, D/C# = 1 (data)
	for (uint16_t i = 0; i < size; i++) {
		i2cWriteByte(data[i]);
	}
	i2cStop();
}

void SSD1306_SoftwareI2C::init() {
	// Set pins to output (open-drain assumed by hardware configuration)
	// Make sure you configured the GPIOs as output push-pull or open-drain externally

	HAL_Delay(300); // Wait for power up

	sendCommand(0xAE);             // Display off
	sendCommand(0xD5);
	sendCommand(0x80); // Set display clock div
	sendCommand(0xA8);
	sendCommand(0x3F); // Multiplex 64
	sendCommand(0xD3);
	sendCommand(0x00); // Display offset 0
	sendCommand(0x40);             // Start line 0
	sendCommand(0x8D);
	sendCommand(0x14); // Charge pump ON
	sendCommand(0x20);
	sendCommand(0x00); // Memory mode horizontal
	sendCommand(0xA1);             // Segment remap
	sendCommand(0xC8);             // COM scan dec
	sendCommand(0xDA);
	sendCommand(0x12); // COM pins
	sendCommand(0x81);
	sendCommand(0xCF); // Contrast
	sendCommand(0xD9);
	sendCommand(0xF1); // Precharge
	sendCommand(0xDB);
	sendCommand(0x40); // VCOM detect
	sendCommand(0xA4);             // Resume RAM display
	sendCommand(0xA6);             // Normal display
	sendCommand(0xAF);             // Display ON

	clearBuffer();
	displayBuffer();
}

void SSD1306_SoftwareI2C::clearBuffer() {
	for (int i = 0; i < sizeof(buffer); i++) {
		buffer[i] = 0x00;
	}
}

void SSD1306_SoftwareI2C::displayBuffer() {
	for (uint8_t page = 0; page < 8; page++) {
		sendCommand(0xB0 + page);    // Set page address
		sendCommand(0x00);           // Set lower column start address
		sendCommand(0x10);           // Set higher column start address
		sendData(&buffer[page * 128], 128);
	}
}

void SSD1306_SoftwareI2C::setPixel(uint8_t x, uint8_t y, bool on) {
	if (x >= 128 || y >= 64)
		return;
	uint16_t index = x + (y / 8) * 128;
	if (on) {
		buffer[index] |= (1 << (y % 8));
	} else {
		buffer[index] &= ~(1 << (y % 8));
	}
}

void SSD1306_SoftwareI2C::drawChar(uint8_t x, uint8_t y, char c) {
	if (c < 32 || c > 127)
		c = ' ';
	const uint8_t *charData = Font5x7[c - 32];
	for (uint8_t i = 0; i < 5; i++) {
		uint8_t line = charData[i];
		for (uint8_t j = 0; j < 8; j++) {
			setPixel(x + i, y + j, line & 0x01);
			line >>= 1;
		}
	}
}

void SSD1306_SoftwareI2C::drawText(uint8_t x, uint8_t y, const char *str) {
	while (*str) {
		drawChar(x, y, *str++);
		x += 6;
		if (x + 5 >= 128)
			break;
	}
}
